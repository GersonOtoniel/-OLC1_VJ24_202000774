package javacup;
import java.util.ArrayList;
import java_cup.runtime.*;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.*;
import Clases.*;
import java.util.Arrays;
import java.util.List;

parser code {:
    public String resultado = "";
    public boolean estadograf = false;
    public boolean estadobar = false;
    public int titulobar = 0;
    
    public  String getResultado(){
        return resultado;
    }
    public void syntax_error(Symbol s) {
        System.out.println("Error Sintactico en la Linea " + (s.left) +
                " Columna " + s.right + ". No se esperaba este componente: " + s.value + ".");
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.out.println("Error s√≠ntactico irrecuperable en la Linea " +
                s.left + " Columna " + s.right + ". Componente " + s.value +
                " no reconocido.");
    }
:}

terminal  COMA, PRINTLN, CONSOLE, END, CHAR, DOUBLE, VAR, SUMA, MENOS, ARROBAID, INT, BOOL;
terminal  MULTIPLICACION, IGUALACION, DIFERENTE, MENORIGUAL, MAYORIGUAL, DIVISION, POTENCIA, MODULO;
terminal  IGUAL, REASIGN, CONST, OR, AND, XOR, NOT, DECIMAL, TKSTRING, UMENOS;
terminal  ASIGN, PYC, DP, MENORQ, MAYORQ, PARENABRE, PARENCIERRA, CORCHABRE, CORCHCIERRA, UNDERSCORE;
terminal  ID, TRUE, FALSE, TKCHAR;
terminal  STRING, ENTERO, ARROW, DEFAULT;
terminal  DEC, INC, TKIF, FOR, ELSE, MATCH, WHILE, RETURN, DO, TKBREAK, TKCONTINUE;


non terminal LinkedList<Instruccion> INIT, instrucciones;
non terminal Instruccion instruccion;

non terminal TIPO;
non terminal MUTACION, IDS, BLOQUEIF;
non terminal Instruccion PRINT, DECLARACION, ASIGNACION, INC_DECINS, IF, BLOCKINS;
non terminal Instruccion INSWHILE, BREAK, INSFOR, IDFOR, CONTINUE, DOWHILEINS, MATCHINS;
non terminal Instruccion DEFAULTINS, CASE, EXPRESIONFOR;
non terminal ArrayList<Instruccion> CASES;
non terminal ArrayList<Object> BLOCKCASES;
non terminal Expresion EXPRESION, INCRE_DECRE;



precedence left OR;
precedence left AND;
precedence left XOR;
precedence right NOT;
precedence left IGUALACION, DIFERENTE, MENORQ, MAYORQ, MENORIGUAL, MAYORIGUAL;
precedence left SUMA, MENOS;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence nonassoc POTENCIA;
precedence right UMENOS;


start with INIT;

INIT ::= instrucciones:a {: RESULT = a; :}
        
        
;

instrucciones::= instrucciones:a instruccion:b {: RESULT = a; RESULT.add(b); :}
                |instruccion:a {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

instruccion ::= DECLARACION:as PYC {: RESULT = as; :}
                |ASIGNACION:a PYC {: RESULT = a; :}
                |INC_DECINS:a PYC {: RESULT = a; :}
                |IF:a {: RESULT = a; :}
                |INSFOR:a {: RESULT = a; :}
                |BREAK:a PYC {: RESULT =a; :}
                |CONTINUE:a PYC {: RESULT = a; :}
                |MATCHINS:a  {: RESULT = a; :}
                |INSWHILE:a {: RESULT = a; :}
                |DOWHILEINS:a PYC {: RESULT = a; :}
                |PRINT:a PYC {: RESULT = a; :}
                |error PYC
                |error

;

INC_DECINS::= ID:a INC:b {: RESULT = new IncDecIns(aleft, aright, a.toString(), b.toString()); :}
             |ID:a DEC:b {: RESULT = new IncDecIns(aleft, aright, a.toString(), b.toString()); :}
;

DECLARACION ::= MUTACION:a  ID:b DP TIPO:c IGUAL EXPRESION:d {: RESULT = new Declaration(bleft, bright, b.toString(), c.toString(), d, a.toString()); :}
             | MUTACION:a ID:b DP TIPO:c {: RESULT = new Declaration(bleft, bright, b.toString(), c.toString(), null, a.toString()); :}
;

ASIGNACION ::= ID:a IGUAL EXPRESION:b {: RESULT = new Assign(aleft, aright, a.toString(), b); :}
;


PRINT ::= PRINTLN PARENABRE EXPRESION:a PARENCIERRA {: RESULT = new Print(aleft, aright, a); :}
;

IF::= TKIF:c PARENABRE EXPRESION:a PARENCIERRA BLOCKINS:b {: RESULT = new If(cleft, cright, a, b, null); :}
     |TKIF:c PARENABRE EXPRESION:a PARENCIERRA BLOCKINS:b ELSE BLOCKINS:d {: RESULT = new If(cleft, cright, a, b, d); :}
     |TKIF:c PARENABRE EXPRESION:a PARENCIERRA BLOCKINS:b ELSE IF:d {: RESULT = new If(cleft, cright, a, b, d); :}
;


MATCHINS ::= MATCH:a EXPRESION:b CORCHABRE BLOCKCASES:c CORCHCIERRA {: RESULT = new Match(aleft, aright, b, (ArrayList<Instruccion>) c.get(0),(Instruccion)c.get(1));  :}
;






BLOCKCASES::= CASES:a DEFAULTINS:b {: ArrayList<Object> lista = new ArrayList<>();lista.add(a); lista.add(b); RESULT = lista; :}
             |CASES:a {: ArrayList<Object> lista = new ArrayList<>(); lista.add(a); lista.add(null); RESULT = lista; :}
             |DEFAULTINS:a {: ArrayList<Object> lista = new ArrayList<>(); lista.add(null); lista.add(a); RESULT= lista; :}
;

CASES::= CASES:b CASE:a {:   RESULT = b; RESULT.add((Instruccion)a); :}
        |CASE:a {: RESULT = new ArrayList<>(); RESULT.add((Instruccion)a); :}
;




CASE::= EXPRESION:a ARROW CORCHABRE instrucciones:b CORCHCIERRA {: RESULT = new Case(aleft, aright, a, new BloqueIns(bleft, bright, b)); :}
;

DEFAULTINS ::= DEFAULT:b ARROW CORCHABRE instrucciones:a CORCHCIERRA {: RESULT = new BloqueIns(bleft, bright, a); :}
;



INSWHILE::=WHILE:a PARENABRE EXPRESION:b PARENCIERRA BLOCKINS:c {: RESULT = new While(aleft, aright, b, c); :}
;

DOWHILEINS::=DO:a BLOCKINS:b WHILE PARENABRE EXPRESION:c PARENCIERRA {: RESULT = new DoWhile(aleft, aright, c, b); :}
;

INSFOR::=FOR:a PARENABRE IDFOR:b PYC  EXPRESION:c PYC EXPRESIONFOR:d PARENCIERRA BLOCKINS:e {: RESULT = new For(aleft, aright, b, c, d, (BloqueIns)e); :}
;

EXPRESIONFOR ::= ASIGNACION:a {: RESULT = a; :}
                |INC_DECINS:a {: RESULT = a; :}
;

IDFOR::= ID:a IGUAL EXPRESION:b {: RESULT = new Assign(aleft, aright, a.toString(), b); :}
;

BLOCKINS ::= CORCHABRE:b instrucciones:a CORCHCIERRA {: RESULT = new BloqueIns(bleft, bright,a); :}
;

BREAK::=TKBREAK:a {: RESULT = new Break(aleft, aright); :}
;

CONTINUE::=TKCONTINUE:a {: RESULT = new Continue(aleft, aright); :}
;

MUTACION ::= VAR:varr {: RESULT = varr; :}
            |CONST:constante {: RESULT = constante; :}
;
               
TIPO ::= CHAR:a {: RESULT = a; :}
        |DOUBLE:b {: RESULT = b; :}
        |INT:c {: RESULT = c; :}
        |BOOL:d {: RESULT = d; :}
        |TKSTRING:e {: RESULT = e; :}
;

EXPRESION ::=|INCRE_DECRE:a {: RESULT = a; :}
            |EXPRESION:a MODULO:b EXPRESION:c {:RESULT = new Arithmetics(aleft, aright, a, b.toString(), c); :}
            |EXPRESION:a SUMA:b EXPRESION:c {: RESULT = new Arithmetics(aleft, aright, a, b.toString(), c); :}
            |EXPRESION:a MENOS:b EXPRESION:c {: RESULT = new Arithmetics(aleft, aright, a, b.toString(), c); :}
            |EXPRESION:a MULTIPLICACION:b EXPRESION:c {: RESULT = new Arithmetics(aleft, aright, a, b.toString(), c); :}
            |EXPRESION:a DIVISION:b EXPRESION:c {: RESULT = new Arithmetics(aleft, aright, a, b.toString(), c); :}
            |EXPRESION:a POTENCIA:b EXPRESION:c {: RESULT = new Arithmetics(aleft, aright, a, b.toString(), c); :}
            |EXPRESION:a IGUALACION:b EXPRESION:c {: RESULT = new Relacional(aleft, aright, a, b.toString(), c);:}
            |EXPRESION:a DIFERENTE:b EXPRESION:c {: RESULT = new Relacional(aleft, aright, a, b.toString(), c);:}
            |EXPRESION:a MENORQ:b EXPRESION:c {: RESULT = new Relacional(aleft, aright, a, b.toString(), c);:}
            |EXPRESION:a MAYORQ:b EXPRESION:c {: RESULT = new Relacional(aleft, aright, a, b.toString(), c); :}
            |EXPRESION:a MAYORIGUAL:b EXPRESION:c {: RESULT = new Relacional(aleft, aright, a, b.toString(), c); :} 
            |EXPRESION:a MENORIGUAL:b EXPRESION:c {: RESULT = new Relacional(aleft, aright, a, b.toString(), c); :}
            |EXPRESION:a AND:b EXPRESION:c {: RESULT = new Logic(aleft, aright, a, b.toString(), c); :}
            |EXPRESION:a XOR:b EXPRESION:c {: RESULT = new Logic(aleft, aright, a, b.toString(), c); :}
            |EXPRESION:a OR:b EXPRESION:c {: RESULT = new Logic(aleft, aright, a, b.toString(), c); :}
            |NOT:a EXPRESION:b {: RESULT = new Logic(aleft, aright, b, a.toString(), null); :}
            |MENOS:a EXPRESION:b {: RESULT = new Arithmetics(aleft, aright, b, a.toString(), null); :}%prec UMENOS
            |PARENABRE EXPRESION:a PARENCIERRA {: RESULT = a; :}
            |PARENABRE TIPO:a PARENCIERRA EXPRESION:b {: RESULT = new Cast(aleft, aright, a.toString(), b); :}%prec UMENOS
            |STRING:strin {: RESULT = new Primitive(strinleft, strinright, strin!=null?QuitarComillas.comillas(strin.toString()):QuitarComillas.comillas(null) , Types.STRING); :}
            |ID:id {: RESULT = new Id_Acces(idleft, idright, id.toString()); :}
            |DECIMAL:decimal {: RESULT = new Primitive(decimalleft, decimalright, decimal, Types.DECIMAL); :}
            |ENTERO:entero {: RESULT = new Primitive(enteroleft, enteroright, entero, Types.INT); :}
            |TRUE:a {: RESULT = new Primitive(aleft, aright, a, Types.BOOL); :}
            |FALSE:a {: RESULT = new Primitive(aleft, aright, a, Types.BOOL); :}
            |TKCHAR:a {: RESULT = new Primitive(aleft, aright, a, Types.CHAR); :}
;


INCRE_DECRE::= ID:a INC:b {: RESULT = new IncDec(aleft, aright, a.toString(), b.toString()); :}
              |ID:a DEC:b {: RESULT = new IncDec(aleft, aright, a.toString(), b.toString()); :}  
;
